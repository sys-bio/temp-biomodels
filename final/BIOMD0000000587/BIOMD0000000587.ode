
#
# This file is automatically generated with 
# the System Biology Format Converter (http://sbfc.sourceforge.net/)
# from an SBML file.
#

#
# Model name = Karapetyan2016 - Genetic oscillatory network - Repressor Titration Circuit (RTC)
#
# is http://identifiers.org/biomodels.db/MODEL1512100001
# is http://identifiers.org/biomodels.db/BIOMD0000000587
# isDescribedBy http://identifiers.org/pubmed/26764732
#

# some function definitions that are allowed in SBML but not valid in xpp
ceil(x)=flr(1+x)

@delay=50


# FunctionDefinition id = Constant_flux__irreversible, name = Constant flux (irreversible)
Constant_(v)=(v)


# Compartment: id = yeast, name = yeast, constant
par yeast=1.0

# Parameter:   id =  Theta, name = Theta, constant
par Theta=0.02

# Parameter:   id =  Alpha, name = Alpha, defined by a Rule

# Parameter:   id =  rho_f, name = rho_f, constant
par rho_f=0.8928

# Parameter:   id =  rho_b, name = rho_b, defined by a Rule

# Parameter:   id =  rho_0, name = rho_0, defined by a Rule

# Parameter:   id =  beta, name = beta, constant
par beta=14.109

# Parameter:   id =  delta_m, name = delta_m, constant
par delta_m=0.0159

# Parameter:   id =  delta_p, name = delta_p, constant
par delta_p=0.0077

# Parameter:   id =  gamma, name = gamma, constant
par gamma=0.025

# Parameter:   id =  epsilon, name = epsilon, constant
par epsilon=0.024

# Parameter:   id =  epsilon_1, name = epsilon_1, constant
par epsilon_1=6.0

# Parameter:   id =  a_01, name = a_01, defined by a Rule

# Parameter:   id =  a_12, name = a_12, defined by a Rule

# Parameter:   id =  a_23, name = a_23, defined by a Rule

# Parameter:   id =  t_10, name = t_10, defined by a Rule

# Parameter:   id =  t_21, name = t_21, defined by a Rule

# Parameter:   id =  t_32, name = t_32, defined by a Rule

# Parameter:   id =  _3sites, name = 3sites, constant
par _3sites=0.0

# Parameter:   id =  f, name = f, constant
par f=3.63

# Parameter:   id =  ModelValue_17, name = Initial for 3sites, constant
par ModelValu=0.0

# Parameter:   id =  ModelValue_1, name = Initial for Alpha, constant
par ModelVa_1=2.49202551834131E-4

# Parameter:   id =  ModelValue_0, name = Initial for Theta, constant
par ModelVa_2=0.02

# Parameter:   id =  ModelValue_18, name = Initial for f, constant
par ModelVa_3=3.63

# Parameter:   id =  ModelValue_3, name = Initial for rho_b, constant
par ModelVa_4=0.245950413223141

# Parameter:   id =  ModelValue_2, name = Initial for rho_f, constant
par ModelVa_5=0.8928

# assignmentRule: variable = Alpha
Alpha=ModelVa_2/(24*3.344)
aux Alpha=Alpha

# assignmentRule: variable = rho_b
rho_b=ModelVa_5/ModelVa_3
aux rho_b=rho_b

# assignmentRule: variable = rho_0
rho_0=(ModelVa_4*ModelVa_5)^(0.5)
aux rho_0=rho_0

# assignmentRule: variable = a_01
a_01= piecew1 
aux a_01=a_01

# assignmentRule: variable = a_12
a_12= piecew2 
aux a_12=a_12

# assignmentRule: variable = a_23
a_23= piecew3 
aux a_23=a_23

# assignmentRule: variable = t_10
t_10=ModelVa_2
aux t_10=t_10

# assignmentRule: variable = t_21
t_21= piecew4 
aux t_21=t_21

# assignmentRule: variable = t_32
t_32= piecew5 
aux t_32=t_32

# Reaction: id = G1____G0___R2, name = G1 -> G0 + R2

G1____G0_=yeast*t_10*G1

# Reaction: id = G0___R2____G1, name = G0 + R2 -> G1

G0___R2__=yeast*a_01*G0*R2

# Reaction: id = G0____G0___rR, name = G0 -> G0 + rR

G0____G0_=yeast*rho_f*G0

# Reaction: id = G1____G1___rR, name = G1 -> G1 + rR

G1____G1_=yeast*rho_b*G1

# Reaction: id = rR___, name = rR -> 

rR___=yeast*delta_m*rR

# Reaction: id = ____rI, name =  -> rI

____rI=yeast*Constant_(rho_0)

# Reaction: id = rI___, name = rI -> 

rI___=yeast*delta_m*rI

# Reaction: id = rR____rR___R, name = rR -> rR + R

rR____rR_=yeast*beta*rR

# Reaction: id = I___, name = I -> 

I___=yeast*delta_p*I

# Reaction: id = rI____rI___I, name = rI -> rI + I

rI____rI_=yeast*beta*rI

# Reaction: id = R___, name = R -> 

R___=yeast*delta_p*R

# Reaction: id = R___I____RI, name = R + I -> RI

R___I____=yeast*gamma*R*I

# Reaction: id = _2___R____R2, name = 2 * R -> R2

_2___R___=yeast*gamma*R^2

# Reaction: id = R2____2___R, name = R2 -> 2 * R

R2____2__=yeast*epsilon_1*R2

# Reaction: id = RI____R___I, name = RI -> R + I

RI____R__=yeast*epsilon*RI_1

# Reaction: id = RI___, name = RI -> 

RI____1=yeast*delta_p*RI_1

# Reaction: id = R2___, name = R2 -> 

R2___=yeast*delta_p*R2

# Reaction: id = G1___R2____G2, name = G1 + R2 -> G2

G1___R2__=yeast*a_12*G1*R2

# Reaction: id = G2____G1___R2, name = G2 -> G1 + R2

G2____G1_=yeast*t_21*G2

# Reaction: id = G2____G2___rR, name = G2 -> G2 + rR

G2____G2_=yeast*rho_b*G2

# Reaction: id = G2___R2____G3, name = G2 + R2 -> G3

G2___R2__=yeast*a_23*G2*R2

# Reaction: id = G3____G2___R2, name = G3 -> G2 + R2

G3____G2_=yeast*t_32*G3

# Reaction: id = G3____G3___rR, name = G3 -> G3 + rR

G3____G3_=yeast*rho_b*G3

# Species:   id = G0, name = G0, affected by kineticLaw

init G0=1.0
dG0/dt=(1/(yeast))*(( 1.0 * G1____G0_) + (-1.0 * G0___R2__) + (-1.0 * G0____G0_) + ( 1.0 * G0____G0_))

# Species:   id = G1, name = G1, affected by kineticLaw

init G1=0.0
dG1/dt=(1/(yeast))*((-1.0 * G1____G0_) + ( 1.0 * G0___R2__) + (-1.0 * G1____G1_) + ( 1.0 * G1____G1_) + (-1.0 * G1___R2__) + ( 1.0 * G2____G1_))

# Species:   id = rR, name = rR, affected by kineticLaw

init rR=0.0
drR/dt=(1/(yeast))*(( 1.0 * G0____G0_) + ( 1.0 * G1____G1_) + (-1.0 * rR___) + (-1.0 * rR____rR_) + ( 1.0 * rR____rR_) + ( 1.0 * G2____G2_) + ( 1.0 * G3____G3_))

# Species:   id = I, name = I, affected by kineticLaw

init I=0.0
dI/dt=(1/(yeast))*((-1.0 * I___) + ( 1.0 * rI____rI_) + (-1.0 * R___I____) + ( 1.0 * RI____R__))

# Species:   id = rI, name = rI, affected by kineticLaw

init rI=0.0
drI/dt=(1/(yeast))*(( 1.0 * ____rI) + (-1.0 * rI___) + (-1.0 * rI____rI_) + ( 1.0 * rI____rI_))

# Species:   id = R, name = R, affected by kineticLaw

init R=0.0
dR/dt=(1/(yeast))*(( 1.0 * rR____rR_) + (-1.0 * R___) + (-1.0 * R___I____) + (-2.0 * _2___R___) + ( 2.0 * R2____2__) + ( 1.0 * RI____R__))

# Species:   id = RI, name = RI, affected by kineticLaw

par RI_1=0.0
aux RI_1=RI_1
dRI_1/dt=(1/(yeast))*(( 1.0 * R___I____) + (-1.0 * RI____R__) + (-1.0 * RI____1))

# Species:   id = R2, name = R2, affected by kineticLaw

init R2=0.0
dR2/dt=(1/(yeast))*(( 1.0 * G1____G0_) + (-1.0 * G0___R2__) + ( 1.0 * _2___R___) + (-1.0 * R2____2__) + (-1.0 * R2___) + (-1.0 * G1___R2__) + ( 1.0 * G2____G1_) + (-1.0 * G2___R2__) + ( 1.0 * G3____G2_))

# Species:   id = G2, name = G2, affected by kineticLaw

init G2=0.0
dG2/dt=(1/(yeast))*(( 1.0 * G1___R2__) + (-1.0 * G2____G1_) + (-1.0 * G2____G2_) + ( 1.0 * G2____G2_) + (-1.0 * G2___R2__) + ( 1.0 * G3____G2_))

# Species:   id = G3, name = G3, affected by kineticLaw

init G3=0.0
dG3/dt=(1/(yeast))*(( 1.0 * G2___R2__) + (-1.0 * G3____G2_) + (-1.0 * G3____G3_) + ( 1.0 * G3____G3_))


# Piecewise functions : the mathML piecewise element is transformed into if/then/else expression

piecew1=if (ModelValu  ==  1) then (3*ModelVa_1) else (ModelVa_1)

piecew2=if (ModelValu  ==  1) then (2*ModelVa_1) else (0)

piecew3=if (ModelValu  ==  1) then (1*ModelVa_1) else (0)

piecew4=if (ModelValu  ==  1) then (2*ModelVa_2) else (0)

piecew5=if (ModelValu  ==  1) then (3*ModelVa_2) else (0)


@ meth=cvode, tol=1e-6, atol=1e-8
# @ maxstor=1e6
@ bound=40000, total=200
done

