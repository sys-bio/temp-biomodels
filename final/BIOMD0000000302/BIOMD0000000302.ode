
#
# This file is automatically generated with 
# the System Biology Format Converter (http://sbfc.sourceforge.net/)
# from an SBML file.
#

#
# Model name = Wang1996_Synaptic_Inhibition_Two_Neuron
#
# is http://identifiers.org/biomodels.db/MODEL1101240000
# is http://identifiers.org/biomodels.db/BIOMD0000000302
# isDescribedBy http://identifiers.org/pubmed/8815919
#

# some function definitions that are allowed in SBML but not valid in xpp
ceil(x)=flr(1+x)

@delay=50


# Compartment: id = pre_synaptic_cell, name = pre_synaptic_cell, constant
par pre_synap=1.0

# Compartment: id = post_synaptic_cell, name = post_synaptic_cell, constant
par post_syna=1.0

# Parameter:   id =  Cm, name = Cm, constant
par Cm=1.0

# Parameter:   id =  gL, name = gL, constant
par gL=0.1

# Parameter:   id =  gK, name = gK, constant
par gK=9.0

# Parameter:   id =  gNa, name = gNa, constant
par gNa=35.0

# Parameter:   id =  E_K, name = E_K, constant
par E_K=-90.0

# Parameter:   id =  E_L, name = E_L, constant
par E_L=-65.0

# Parameter:   id =  E_Na, name = E_Na, constant
par E_Na=55.0

# Parameter:   id =  phi, name = phi, constant
par phi=5.0

# Parameter:   id =  tau_0, name = tau_0, defined by a Rule

# Parameter:   id =  I_app_post, name = I_app_post, constant
par I_app_pos=0.0

# Parameter:   id =  I_Na_post, name = I_Na_post, defined by a Rule

# Parameter:   id =  m_inf_post, name = m_inf_post, defined by a Rule

# Parameter:   id =  h_post, name = h_post, defined by a Rule

# Parameter:   id =  V_post, name = V_post, defined by a Rule

# Parameter:   id =  alpha_m_post, name = alpha_m_post, defined by a Rule

# Parameter:   id =  beta_m_post, name = beta_m_post, defined by a Rule

# Parameter:   id =  alpha_h_post, name = alpha_h_post, defined by a Rule

# Parameter:   id =  beta_h_post, name = beta_h_post, defined by a Rule

# Parameter:   id =  I_K_post, name = I_K_post, defined by a Rule

# Parameter:   id =  n_post, name = n_post, defined by a Rule

# Parameter:   id =  alpha_n_post, name = alpha_n_post, defined by a Rule

# Parameter:   id =  beta_n_post, name = beta_n_post, defined by a Rule

# Parameter:   id =  I_L_post, name = I_L_post, defined by a Rule

# Parameter:   id =  I_syn, name = I_syn, defined by a Rule

# Parameter:   id =  g_syn, name = g_syn, constant
par g_syn=0.1

# Parameter:   id =  s, name = s, defined by a Rule

# Parameter:   id =  E_syn, name = E_syn, constant
par E_syn=-75.0

# Parameter:   id =  alpha, name = alpha, constant
par alpha=12.0

# Parameter:   id =  F, name = F, defined by a Rule

# Parameter:   id =  beta, name = beta, constant
par beta=0.1

# Parameter:   id =  V_pre, name = V_pre, defined by a Rule

# Parameter:   id =  theta_syn, name = theta_syn, constant
par theta_syn=0.0

# Parameter:   id =  I_app_pre, name = I_app_pre, defined by a Rule

# Parameter:   id =  I_Na_pre, name = I_Na_pre, defined by a Rule

# Parameter:   id =  m_inf_pre, name = m_inf_pre, defined by a Rule

# Parameter:   id =  h_pre, name = h_pre, defined by a Rule

# Parameter:   id =  n_pre, name = n_pre, defined by a Rule

# Parameter:   id =  alpha_n_pre, name = alpha_n_pre, defined by a Rule

# Parameter:   id =  beta_n_pre, name = beta_n_pre, defined by a Rule

# Parameter:   id =  alpha_h_pre, name = alpha_h_pre, defined by a Rule

# Parameter:   id =  beta_h_pre, name = beta_h_pre, defined by a Rule

# Parameter:   id =  alpha_m_pre, name = alpha_m_pre, defined by a Rule

# Parameter:   id =  beta_m_pre, name = beta_m_pre, defined by a Rule

# Parameter:   id =  I_K_pre, name = I_K_pre, defined by a Rule

# Parameter:   id =  I_L_pre, name = I_L_pre, defined by a Rule

# assignmentRule: variable = tau_0
tau_0=Cm/gL
aux tau_0=tau_0

# assignmentRule: variable = I_Na_post
I_Na_post=gNa*m_inf_pos^3*h_post*(V_post-E_Na)
aux I_Na_post=I_Na_post

# assignmentRule: variable = m_inf_post
m_inf_pos=alpha_m_p/(alpha_m_p+beta_m_po)
aux m_inf_pos=m_inf_pos

# rateRule: variable = h_post
dh_post/dt=phi*(alpha_h_p*(1-h_post)-beta_h_po*h_post)

# rateRule: variable = V_post
init V_post=-64.0
dV_post/dt=(I_app_pos-(I_Na_post+I_K_post+I_L_post+I_syn))/Cm

# assignmentRule: variable = alpha_m_post
alpha_m_p=(-0.1)*(V_post+35)/(exp((-0.1)*(V_post+35))-1)
aux alpha_m_p=alpha_m_p

# assignmentRule: variable = beta_m_post
beta_m_po=4*exp((-(V_post+60))/18)
aux beta_m_po=beta_m_po

# assignmentRule: variable = alpha_h_post
alpha_h_p=0.07*exp((-(V_post+58))/20)
aux alpha_h_p=alpha_h_p

# assignmentRule: variable = beta_h_post
beta_h_po=1/(exp((-0.1)*(V_post+28))+1)
aux beta_h_po=beta_h_po

# assignmentRule: variable = I_K_post
I_K_post=gK*n_post^4*(V_post-E_K)
aux I_K_post=I_K_post

# rateRule: variable = n_post
dn_post/dt=phi*(alpha_n_p*(1-n_post)-beta_n_po*n_post)

# assignmentRule: variable = alpha_n_post
alpha_n_p=(-0.01)*(V_post+34)/(exp((-0.1)*(V_post+34))-1)
aux alpha_n_p=alpha_n_p

# assignmentRule: variable = beta_n_post
beta_n_po=0.125*exp((-(V_post+44))/80)
aux beta_n_po=beta_n_po

# assignmentRule: variable = I_L_post
I_L_post=gL*(V_post-E_L)
aux I_L_post=I_L_post

# assignmentRule: variable = I_syn
I_syn=g_syn*s*(V_post-E_syn)
aux I_syn=I_syn

# rateRule: variable = s
ds/dt=alpha*F*(1-s)-beta*s

# assignmentRule: variable = F
F=1/(1+exp((-(V_pre-theta_syn))/2))
aux F=F

# rateRule: variable = V_pre
init V_pre=-64.0
dV_pre/dt=(I_app_pre-(I_Na_pre+I_K_pre+I_L_pre))/Cm

# assignmentRule: variable = I_app_pre
I_app_pre= piecew1 
aux I_app_pre=I_app_pre

# assignmentRule: variable = I_Na_pre
I_Na_pre=gNa*m_inf_pre^3*h_pre*(V_pre-E_Na)
aux I_Na_pre=I_Na_pre

# assignmentRule: variable = m_inf_pre
m_inf_pre=alpha_m_1/(alpha_m_1+beta_m_pr)
aux m_inf_pre=m_inf_pre

# rateRule: variable = h_pre
dh_pre/dt=phi*(alpha_h_1*(1-h_pre)-beta_h_pr*h_pre)

# rateRule: variable = n_pre
dn_pre/dt=phi*(alpha_n_1*(1-n_pre)-beta_n_pr*n_pre)

# assignmentRule: variable = alpha_n_pre
alpha_n_1=(-0.01)*(V_pre+34)/(exp((-0.1)*(V_pre+34))-1)
aux alpha_n_1=alpha_n_1

# assignmentRule: variable = beta_n_pre
beta_n_pr=0.125*exp((-(V_pre+44))/80)
aux beta_n_pr=beta_n_pr

# assignmentRule: variable = alpha_h_pre
alpha_h_1=0.07*exp((-(V_pre+58))/20)
aux alpha_h_1=alpha_h_1

# assignmentRule: variable = beta_h_pre
beta_h_pr=1/(exp((-0.1)*(V_pre+28))+1)
aux beta_h_pr=beta_h_pr

# assignmentRule: variable = alpha_m_pre
alpha_m_1=(-0.1)*(V_pre+35)/(exp((-0.1)*(V_pre+35))-1)
aux alpha_m_1=alpha_m_1

# assignmentRule: variable = beta_m_pre
beta_m_pr=4*exp((-(V_pre+60))/18)
aux beta_m_pr=beta_m_pr

# assignmentRule: variable = I_K_pre
I_K_pre=gK*n_pre^4*(V_pre-E_K)
aux I_K_pre=I_K_pre

# assignmentRule: variable = I_L_pre
I_L_pre=gL*(V_pre-E_L)
aux I_L_pre=I_L_pre


# Piecewise functions : the mathML piecewise element is transformed into if/then/else expression

piecew1=if ((t  >=  10) && (t  <=  20)) then (2) else (0)


@ meth=cvode, tol=1e-6, atol=1e-8
# @ maxstor=1e6
@ bound=40000, total=200
done

