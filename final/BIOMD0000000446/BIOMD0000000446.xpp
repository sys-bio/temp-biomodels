
#
# This file is automatically generated with 
# the System Biology Format Converter (http://sbfc.sourceforge.net/)
# from an SBML file.
#

#
# Model name = Erguler2013 - Unfolded protein stress response
#
# is http://identifiers.org/biomodels.db/MODEL1302180000
# is http://identifiers.org/biomodels.db/BIOMD0000000446
# isDescribedBy http://identifiers.org/pubmed/23433609
#

# some function definitions that are allowed in SBML but not valid in xpp
ceil(x)=flr(1+x)

@delay=50


# FunctionDefinition id = EMM, name = EMM
EMM(St,Et,Km,kcat)=(0.5*kcat*(St+Et+Km-((St+Et+Km)^2-4*St*Et)^(0.5)))


# FunctionDefinition id = Gamma, name = Gamma
Gamma(v,u,J,K)=(v-u+v*J+u*K)


# FunctionDefinition id = fGK, name = fGK
fGK(v,u,J,K,u,J,u,J)=(piecewise(0,(v == 0) && (u == 0),2*u*K/(Gamma(v,K)+(Gamma(v,K)^2-4*(v-u)*u*K)^(0.5))))


# Compartment: id = ERlumen, name = ERlumen, constant
par ERlumen=1.0

# Compartment: id = cytoplasm, name = cytoplasm, constant
par cytoplasm=1.0

# Compartment: id = Golgi, name = Golgi, constant
par Golgi=1.0

# Compartment: id = mitochondria, name = mitochondria, constant
par mitochond=1.0

# Parameter:   id =  UFP, name = UFP, defined by a Rule

# Parameter:   id =  BiP, name = BiP, defined by a Rule

# Parameter:   id =  IRE1, name = IRE1, defined by a Rule

# Parameter:   id =  PERK, name = PERK, defined by a Rule

# Parameter:   id =  ATF6, name = ATF6, defined by a Rule

# Parameter:   id =  eIF2a, name = eIF2a, defined by a Rule

# Parameter:   id =  spliceRate, name = spliceRate, defined by a Rule

# Parameter:   id =  BCL2, name = BCL2, defined by a Rule

# Parameter:   id =  BH3, name = BH3, defined by a Rule

# Parameter:   id =  BAXm, name = BAXm, defined by a Rule

# Parameter:   id =  tmr, name = tmr, constant
par tmr=10.0

# Parameter:   id =  IRE1T, name = IRE1T, constant
par IRE1T=1.0

# Parameter:   id =  PERKT, name = PERKT, constant
par PERKT=1.0

# Parameter:   id =  eIF2aT, name = eIF2aT, constant
par eIF2aT=1.0

# Parameter:   id =  CReP, name = CReP, constant
par CReP=0.1

# Parameter:   id =  kf, name = kf, constant
par kf=10.0

# Parameter:   id =  kr, name = kr, constant
par kr=1.0

# Parameter:   id =  n, name = n, constant
par n=4.0

# Parameter:   id =  nh, name = nh, constant
par nh=2.0

# Parameter:   id =  extATT, name = extATT, constant
par extATT=0.0

# Parameter:   id =  extPERK, name = extPERK, constant
par extPERK=0.0

# Parameter:   id =  basalXBP, name = basalXBP, constant
par basalXBP=1.0

# Parameter:   id =  basalBiP, name = basalBiP, constant
par basalBiP=1.0

# Parameter:   id =  krcXU, name = krcXU, constant
par krcXU=5.0

# Parameter:   id =  krcBiP, name = krcBiP, constant
par krcBiP=5.0

# Parameter:   id =  krcWFS, name = krcWFS, constant
par krcWFS=1.0

# Parameter:   id =  krcCHOP, name = krcCHOP, constant
par krcCHOP=1.0

# Parameter:   id =  krcGADD34, name = krcGADD34, constant
par krcGADD34=1.0

# Parameter:   id =  kmXbp, name = kmXbp, constant
par kmXbp=10.0

# Parameter:   id =  kmAtfsXBP, name = kmAtfsXBP, constant
par kmAtfsXBP=10.0

# Parameter:   id =  kmAtfsBiP, name = kmAtfsBiP, constant
par kmAtfsBiP=1.0

# Parameter:   id =  kmAtff, name = kmAtff, constant
par kmAtff=0.05

# Parameter:   id =  kmChop, name = kmChop, constant
par kmChop=0.05

# Parameter:   id =  kmAtfs, name = kmAtfs, constant
par kmAtfs=0.1

# Parameter:   id =  ksplice, name = ksplice, constant
par ksplice=10.0

# Parameter:   id =  krcSplice, name = krcSplice, constant
par krcSplice=1.0

# Parameter:   id =  trcXU, name = trcXU, constant
par trcXU=1.0

# Parameter:   id =  trcBiP, name = trcBiP, constant
par trcBiP=1.0

# Parameter:   id =  trcWFS, name = trcWFS, constant
par trcWFS=1.0

# Parameter:   id =  trcCHOP, name = trcCHOP, constant
par trcCHOP=1.0

# Parameter:   id =  trcGADD34, name = trcGADD34, constant
par trcGADD34=1.0

# Parameter:   id =  ktrUFP, name = ktrUFP, constant
par ktrUFP=1.0

# Parameter:   id =  ktrXS, name = ktrXS, constant
par ktrXS=1.0

# Parameter:   id =  ktrBiP, name = ktrBiP, constant
par ktrBiP=1.0

# Parameter:   id =  ktrATF6, name = ktrATF6, constant
par ktrATF6=1.0

# Parameter:   id =  ktrWFS, name = ktrWFS, constant
par ktrWFS=1.0

# Parameter:   id =  ktrATF4, name = ktrATF4, constant
par ktrATF4=1.0

# Parameter:   id =  ktrCHOP, name = ktrCHOP, constant
par ktrCHOP=1.0

# Parameter:   id =  ktrGADD34, name = ktrGADD34, constant
par ktrGADD34=1.0

# Parameter:   id =  kdmXU, name = kdmXU, constant
par kdmXU=1.0

# Parameter:   id =  kdmXS, name = kdmXS, constant
par kdmXS=1.0

# Parameter:   id =  kdmBiP, name = kdmBiP, constant
par kdmBiP=1.0

# Parameter:   id =  kdmWFS, name = kdmWFS, constant
par kdmWFS=1.0

# Parameter:   id =  kdmCHOP, name = kdmCHOP, constant
par kdmCHOP=1.0

# Parameter:   id =  kdmGADD34, name = kdmGADD34, constant
par kdmGADD34=1.0

# Parameter:   id =  kdUFP, name = kdUFP, constant
par kdUFP=0.1

# Parameter:   id =  kdXS, name = kdXS, constant
par kdXS=0.1

# Parameter:   id =  kdBiP, name = kdBiP, constant
par kdBiP=0.01

# Parameter:   id =  kdATF6, name = kdATF6, constant
par kdATF6=0.1

# Parameter:   id =  kdATF6GB, name = kdATF6GB, constant
par kdATF6GB=0.1

# Parameter:   id =  kdATF6p50, name = kdATF6p50, constant
par kdATF6p50=0.1

# Parameter:   id =  kdWFS, name = kdWFS, constant
par kdWFS=0.1

# Parameter:   id =  kdATF4, name = kdATF4, constant
par kdATF4=0.1

# Parameter:   id =  kdCHOP, name = kdCHOP, constant
par kdCHOP=0.1

# Parameter:   id =  kdGADD34, name = kdGADD34, constant
par kdGADD34=0.1

# Parameter:   id =  mATF6T, name = mATF6T, constant
par mATF6T=5.0

# Parameter:   id =  mUFPT, name = mUFPT, defined by a Rule

# Parameter:   id =  mATF4, name = mATF4, constant
par mATF4=1.0

# Parameter:   id =  ktrans, name = ktrans, constant
par ktrans=1.0

# Parameter:   id =  kcleave, name = kcleave, constant
par kcleave=10.0

# Parameter:   id =  kphos, name = kphos, constant
par kphos=5.0

# Parameter:   id =  kdephos, name = kdephos, constant
par kdephos=0.5

# Parameter:   id =  kdeAW, name = kdeAW, constant
par kdeAW=1.0

# Parameter:   id =  kbu, name = kbu, constant
par kbu=0.0

# Parameter:   id =  switch, name = switch, constant
par switch=0.0

# Parameter:   id =  kATF4, name = kATF4, constant
par kATF4=0.1

# Parameter:   id =  J, name = J, constant
par J=0.001

# Parameter:   id =  K, name = K, constant
par K=0.001

# Parameter:   id =  kfbc, name = kfbc, constant
par kfbc=10.0

# Parameter:   id =  kdbc, name = kdbc, constant
par kdbc=0.1

# Parameter:   id =  kmbc, name = kmbc, constant
par kmbc=0.03

# Parameter:   id =  kstr, name = kstr, constant
par kstr=0.2

# Parameter:   id =  BAXT, name = BAXT, constant
par BAXT=100.0

# Parameter:   id =  kfx, name = kfx, constant
par kfx=1.0

# Parameter:   id =  kfxp, name = kfxp, constant
par kfxp=3.0

# Parameter:   id =  kbx, name = kbx, constant
par kbx=2.0

# Parameter:   id =  kasx, name = kasx, constant
par kasx=90.0

# Parameter:   id =  kdsx, name = kdsx, constant
par kdsx=0.05

# Parameter:   id =  ks3, name = ks3, constant
par ks3=0.1

# Parameter:   id =  ks3p, name = ks3p, constant
par ks3p=0.6

# Parameter:   id =  kd3, name = kd3, constant
par kd3=0.01

# Parameter:   id =  kas3, name = kas3, constant
par kas3=10.0

# Parameter:   id =  kds3, name = kds3, constant
par kds3=0.01

# Parameter:   id =  kff, name = kff, constant
par kff=10.0

# assignmentRule: variable = UFP
UFP=UFPT-BiUFP
aux UFP=UFP

# assignmentRule: variable = BiP
BiP=BiPT-BiRE1-BiATF-BiPER-BiUFP
aux BiP=BiP

# assignmentRule: variable = IRE1
IRE1=IRE1T-BiRE1-n*IRE1A
aux IRE1=IRE1

# assignmentRule: variable = PERK
PERK=PERKT-BiPER-n*PERKA
aux PERK=PERK

# assignmentRule: variable = ATF6
ATF6=ATF6T-BiATF
aux ATF6=ATF6

# assignmentRule: variable = spliceRate
spliceRat=EMM(mXbp1u, 0.5*n*IRE1A, krcSplice, ksplice)
aux spliceRat=spliceRat

# assignmentRule: variable = eIF2a
eIF2a=eIF2aT*fGK(kphos*0.5*n*PERKA, kdephos*(GADD34+CReP), J/eIF2aT, K/eIF2aT)
aux eIF2a=eIF2a

# assignmentRule: variable = BCL2
BCL2=BCL2T-BH3BCL2-BAXmBCL2
aux BCL2=BCL2

# assignmentRule: variable = BH3
BH3=BH3T-BH3BCL2
aux BH3=BH3

# assignmentRule: variable = BAXm
BAXm=BAXmT-BAXmBCL2
aux BAXm=BAXm

# assignmentRule: variable = mUFPT
mUFPT=13
aux mUFPT=mUFPT

# Reaction: id = re2

re2=ktrUFP*mUFPT* piecew1 

# Reaction: id = re3

re3=kdUFP*UFPT

# Reaction: id = re4

re4=kbu*BiUFP*UFPT

# Reaction: id = reu1

reu1=tmr*kf*BiP*UFP

# Reaction: id = reu2

reu2=tmr*kr*BiUFP

# Reaction: id = reu3

reu3=tmr*kf*BiP*IRE1

# Reaction: id = reu4

reu4=tmr*kr*BiRE1

# Reaction: id = reu5

reu5=tmr*kf*BiP*ATF6

# Reaction: id = reu6

reu6=tmr*kr*BiATF

# Reaction: id = reu7

reu7=tmr*kf*BiP*PERK

# Reaction: id = reu8

reu8=kr*tmr*BiPER

# Reaction: id = reu9

reu9=tmr*kff*IRE1^n

# Reaction: id = reu10

reu10=tmr*kr*IRE1A

# Reaction: id = reu11

reu11=tmr*kff* piecew2 *PERK^n

# Reaction: id = reu12

reu12=tmr*kr*PERKA/(1+extPERK*UFP)

# Reaction: id = re5

re5=ktrATF6*mATF6T

# Reaction: id = re6

re6=kdATF6*ATF6T

# Reaction: id = re8

re8=ktrans*ATF6

# Reaction: id = rew1

rew1=kdeAW*WFS1*ATF6T

# Reaction: id = re9

re9=kdATF6GB*ATF6GB

# Reaction: id = re10

re10=kcleave*ATF6GB

# Reaction: id = re11

re11=kdATF6p50*ATF6p50

# Reaction: id = rew2

rew2=trcWFS*ATF6p50/(krcWFS+ATF6p50)

# Reaction: id = rew3

rew3=kdmWFS*mWFS1

# Reaction: id = rew4

rew4=ktrWFS*mWFS1

# Reaction: id = rew5

rew5=kdWFS*WFS1

# Reaction: id = re12

re12=trcXU*(basalXBP+kmAtfsXBP*ATF6p50)/(krcXU+basalXBP+kmAtfsXBP*ATF6p50)

# Reaction: id = re13

re13=kdmXU*mXbp1u

# Reaction: id = re14

re14=spliceRat

# Reaction: id = re15

re15=kdmXS*mXbp1s

# Reaction: id = re16

re16=ktrXS*mXbp1s

# Reaction: id = re17

re17=kdXS*Xbp1s

# Reaction: id = re18

re18=trcBiP*(basalBiP+kmXbp*Xbp1s+kmAtfsBiP*ATF6p50)/(krcBiP+basalBiP+kmXbp*Xbp1s+kmAtfsBiP*ATF6p50)

# Reaction: id = re19

re19=kdmBiP*mBiPT

# Reaction: id = re20

re20=ktrBiP*mBiPT

# Reaction: id = re21

re21=kdBiP*BiPT

# Reaction: id = re23

re23=ktrATF4*mATF4/(1+(eIF2a/kATF4)^nh)

# Reaction: id = re24

re24=kdATF4*ATF4

# Reaction: id = re25

re25=trcCHOP*(kmAtff*ATF4+kmAtfs*ATF6p50)/(krcCHOP+kmAtff*ATF4+kmAtfs*ATF6p50)

# Reaction: id = re26

re26=kdmCHOP*mCHOP

# Reaction: id = re27

re27=ktrCHOP*mCHOP

# Reaction: id = re28

re28=kdCHOP*CHOP

# Reaction: id = re29

re29=trcGADD34*kmChop*CHOP/(krcGADD34+kmChop*CHOP)

# Reaction: id = re30

re30=kdmGADD34*mGADD34

# Reaction: id = re31

re31=ktrGADD34*mGADD34

# Reaction: id = re32

re32=kdGADD34*GADD34

# Reaction: id = rea1

rea1=kfbc/(1+kmbc*CHOP)

# Reaction: id = rea2

rea2=kdbc*BCL2T

# Reaction: id = rea3

rea3=kfx*BAXT

# Reaction: id = rea4

rea4=kfxp*BH3*BAXT

# Reaction: id = rea5

rea5=kfx*BAXmT

# Reaction: id = rea6

rea6=kfxp*BH3*BAXmT

# Reaction: id = rea7

rea7=kbx*BAXmT

# Reaction: id = rea8

rea8=ks3

# Reaction: id = rea9

rea9=ks3p*kstr*CHOP

# Reaction: id = rea10

rea10=kd3*BH3T

# Reaction: id = rea11

rea11=kasx*BAXm*BCL2

# Reaction: id = rea12

rea12=kdsx*BAXmBCL2

# Reaction: id = rea13

rea13=kbx*BAXmBCL2

# Reaction: id = rea14

rea14=kas3*BH3*BCL2

# Reaction: id = rea15

rea15=kds3*BH3BCL2

# Reaction: id = rea16

rea16=kd3*BH3BCL2

# Species:   id = UFPT, name = UFPT, affected by kineticLaw

init UFPT=0.0
dUFPT/dt=( 1.0 * re2) + (-1.0 * re3) + (-1.0 * re4)

# Species:   id = BiUFP, name = BiUFP, affected by kineticLaw

init BiUFP=0.0
dBiUFP/dt=( 1.0 * reu1) + (-1.0 * reu2)

# Species:   id = BiRE1, name = BiRE1, affected by kineticLaw

init BiRE1=0.0
dBiRE1/dt=( 1.0 * reu3) + (-1.0 * reu4)

# Species:   id = BiATF, name = BiATF, affected by kineticLaw

init BiATF=0.0
dBiATF/dt=( 1.0 * reu5) + (-1.0 * reu6)

# Species:   id = BiPER, name = BiPER, affected by kineticLaw

init BiPER=0.0
dBiPER/dt=( 1.0 * reu7) + (-1.0 * reu8)

# Species:   id = IRE1A, name = IRE1A, affected by kineticLaw

init IRE1A=0.0
dIRE1A/dt=( 1.0 * reu9) + (-1.0 * reu10)

# Species:   id = PERKA, name = PERKA, affected by kineticLaw

init PERKA=0.0
dPERKA/dt=( 1.0 * reu11) + (-1.0 * reu12)

# Species:   id = mXbp1u, name = mXbp1u, affected by kineticLaw

init mXbp1u=0.0
dmXbp1u/dt=( 1.0 * re12) + (-1.0 * re13) + (-1.0 * re14)

# Species:   id = mXbp1s, name = mXbp1s, affected by kineticLaw

init mXbp1s=0.0
dmXbp1s/dt=( 1.0 * re14) + (-1.0 * re15)

# Species:   id = Xbp1s, name = Xbp1s, affected by kineticLaw

init Xbp1s=0.0
dXbp1s/dt=( 1.0 * re16) + (-1.0 * re17)

# Species:   id = mBiPT, name = mBiPT, affected by kineticLaw

init mBiPT=0.0
dmBiPT/dt=( 1.0 * re18) + (-1.0 * re19)

# Species:   id = BiPT, name = BiPT, affected by kineticLaw

init BiPT=0.0
dBiPT/dt=( 1.0 * re20) + (-1.0 * re21)

# Species:   id = ATF6T, name = ATF6T, affected by kineticLaw

init ATF6T=0.0
dATF6T/dt=( 1.0 * re5) + (-1.0 * re6) + (-1.0 * re8) + (-1.0 * rew1)

# Species:   id = ATF6GB, name = ATF6GB, affected by kineticLaw

init ATF6GB=0.0
dATF6GB/dt=( 1.0 * re8) + (-1.0 * re9) + (-1.0 * re10)

# Species:   id = ATF6p50, name = ATF6p50, affected by kineticLaw

init ATF6p50=0.0
dATF6p50/dt=( 1.0 * re10) + (-1.0 * re11)

# Species:   id = mWFS1, name = mWFS1, affected by kineticLaw

init mWFS1=0.0
dmWFS1/dt=( 1.0 * rew2) + (-1.0 * rew3)

# Species:   id = WFS1, name = WFS1, affected by kineticLaw

init WFS1=0.0
dWFS1/dt=( 1.0 * rew4) + (-1.0 * rew5)

# Species:   id = ATF4, name = ATF4, affected by kineticLaw

init ATF4=0.0
dATF4/dt=( 1.0 * re23) + (-1.0 * re24)

# Species:   id = mCHOP, name = mCHOP, affected by kineticLaw

init mCHOP=0.0
dmCHOP/dt=( 1.0 * re25) + (-1.0 * re26)

# Species:   id = CHOP, name = CHOP, affected by kineticLaw

init CHOP=0.0
dCHOP/dt=( 1.0 * re27) + (-1.0 * re28)

# Species:   id = mGADD34, name = mGADD34, affected by kineticLaw

init mGADD34=0.0
dmGADD34/dt=( 1.0 * re29) + (-1.0 * re30)

# Species:   id = GADD34, name = GADD34, affected by kineticLaw

init GADD34=0.0
dGADD34/dt=( 1.0 * re31) + (-1.0 * re32)

# Species:   id = BCL2T, name = BCL2T, affected by kineticLaw

init BCL2T=0.0
dBCL2T/dt=( 1.0 * rea1) + (-1.0 * rea2)

# Species:   id = BAXmT, name = BAXmT, affected by kineticLaw

init BAXmT=0.0
dBAXmT/dt=( 1.0 * rea3) + ( 1.0 * rea4) + (-1.0 * rea5) + (-1.0 * rea6) + (-1.0 * rea7)

# Species:   id = BH3T, name = BH3T, affected by kineticLaw

init BH3T=0.0
dBH3T/dt=( 1.0 * rea8) + ( 1.0 * rea9) + (-1.0 * rea10)

# Species:   id = BAXmBCL2, name = BAXmBCL2, affected by kineticLaw

init BAXmBCL2=0.0
dBAXmBCL2/dt=( 1.0 * rea11) + (-1.0 * rea12) + (-1.0 * rea13)

# Species:   id = BH3BCL2, name = BH3BCL2, affected by kineticLaw

init BH3BCL2=0.0
dBH3BCL2/dt=( 1.0 * rea14) + (-1.0 * rea15) + (-1.0 * rea16)


# Piecewise functions : the mathML piecewise element is transformed into if/then/else expression

piecew1=if (extATT  ==  1) then (eIF2a/eIF2aT) else (1)

piecew2=if (switch  ==  1) then (UFP) else (1)


@ meth=cvode, tol=1e-6, atol=1e-8
# @ maxstor=1e6
@ bound=40000, total=200
done

