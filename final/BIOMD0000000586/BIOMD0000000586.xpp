
#
# This file is automatically generated with 
# the System Biology Format Converter (http://sbfc.sourceforge.net/)
# from an SBML file.
#

#
# Model name = Karapetyan2016 - Genetic oscillatory network - Activator Titration Circuit (ATC)
#
# is http://identifiers.org/biomodels.db/MODEL1512100000
# is http://identifiers.org/biomodels.db/BIOMD0000000586
# isDescribedBy http://identifiers.org/pubmed/26764732
#

# some function definitions that are allowed in SBML but not valid in xpp
ceil(x)=flr(1+x)

@delay=50


# FunctionDefinition id = Constant_flux__irreversible, name = Constant flux (irreversible)
Constant_(v)=(v)


# Compartment: id = yeast, name = yeast, constant
par yeast=1.0

# Parameter:   id =  Theta, name = Theta, constant
par Theta=0.02

# Parameter:   id =  Alpha, name = Alpha, defined by a Rule

# Parameter:   id =  rho_f, name = rho_f, constant
par rho_f=0.1781

# Parameter:   id =  rho_b, name = rho_b, defined by a Rule

# Parameter:   id =  rho_0, name = rho_0, defined by a Rule

# Parameter:   id =  beta, name = beta, constant
par beta=14.109

# Parameter:   id =  delta_m, name = delta_m, constant
par delta_m=0.0186

# Parameter:   id =  delta_p, name = delta_p, constant
par delta_p=0.0077

# Parameter:   id =  gamma, name = gamma, constant
par gamma=0.025

# Parameter:   id =  epsilon, name = epsilon, constant
par epsilon=0.024

# Parameter:   id =  epsilon_1, name = epsilon_1, constant
par epsilon_1=6.0

# Parameter:   id =  a_01, name = a_01, defined by a Rule

# Parameter:   id =  a_12, name = a_12, defined by a Rule

# Parameter:   id =  a_23, name = a_23, defined by a Rule

# Parameter:   id =  t_10, name = t_10, defined by a Rule

# Parameter:   id =  t_21, name = t_21, defined by a Rule

# Parameter:   id =  t_32, name = t_32, defined by a Rule

# Parameter:   id =  _3sites, name = 3sites, constant
par _3sites=0.0

# Parameter:   id =  f, name = f, constant
par f=30.0

# Parameter:   id =  ModelValue_17, name = Initial for 3sites, constant
par ModelValu=0.0

# Parameter:   id =  ModelValue_1, name = Initial for Alpha, constant
par ModelVa_1=2.49202551834131E-4

# Parameter:   id =  ModelValue_0, name = Initial for Theta, constant
par ModelVa_2=0.02

# Parameter:   id =  ModelValue_18, name = Initial for f, constant
par ModelVa_3=30.0

# Parameter:   id =  ModelValue_3, name = Initial for rho_b, constant
par ModelVa_4=5.343

# Parameter:   id =  ModelValue_2, name = Initial for rho_f, constant
par ModelVa_5=0.1781

# assignmentRule: variable = Alpha
Alpha=ModelVa_2/(24*3.344)
aux Alpha=Alpha

# assignmentRule: variable = rho_b
rho_b=ModelVa_5*ModelVa_3
aux rho_b=rho_b

# assignmentRule: variable = rho_0
rho_0=(ModelVa_4*ModelVa_5)^(0.5)
aux rho_0=rho_0

# assignmentRule: variable = a_01
a_01= piecew1 
aux a_01=a_01

# assignmentRule: variable = a_12
a_12= piecew2 
aux a_12=a_12

# assignmentRule: variable = a_23
a_23= piecew3 
aux a_23=a_23

# assignmentRule: variable = t_10
t_10=ModelVa_2
aux t_10=t_10

# assignmentRule: variable = t_21
t_21= piecew4 
aux t_21=t_21

# assignmentRule: variable = t_32
t_32= piecew5 
aux t_32=t_32

# Reaction: id = G1____G0___A2, name = G1 -> G0 + A2

G1____G0_=yeast*t_10*G1

# Reaction: id = G0___A2____G1, name = G0 + A2 -> G1

G0___A2__=yeast*a_01*G0*A2

# Reaction: id = G____G___rI, name = G -> G + rI

G____G___=yeast*rho_f*G0

# Reaction: id = G1____G1___rI, name = G1 -> G1 + rI

G1____G1_=yeast*rho_b*G1

# Reaction: id = rA___, name = rA -> 

rA___=yeast*delta_m*rA

# Reaction: id = ____rA, name =  -> rA

____rA=yeast*Constant_(rho_0)

# Reaction: id = rI___, name = rI -> 

rI___=yeast*delta_m*rI

# Reaction: id = rA____rA___A, name = rA -> rA + A

rA____rA_=yeast*beta*rA

# Reaction: id = I___, name = I -> 

I___=yeast*delta_p*I

# Reaction: id = rI____rI___I, name = rI -> rI + I

rI____rI_=yeast*beta*rI

# Reaction: id = A___, name = A -> 

A___=yeast*delta_p*A

# Reaction: id = A___I____AI, name = A + I -> AI

A___I____=yeast*gamma*A*I

# Reaction: id = _2___A____A2, name = 2 * A -> A2

_2___A___=yeast*gamma*A^2

# Reaction: id = A2____2___A, name = A2 -> 2 * A

A2____2__=yeast*epsilon_1*A2

# Reaction: id = AI____A___I, name = AI -> A + I

AI____A__=yeast*epsilon*AI

# Reaction: id = AI___, name = AI -> 

AI___=yeast*delta_p*AI

# Reaction: id = A2___, name = A2 -> 

A2___=yeast*delta_p*A2

# Reaction: id = G1___A2____G2, name = G1 + A2 -> G2

G1___A2__=yeast*a_12*G1*A2

# Reaction: id = G2____G1___A2, name = G2 -> G1 + A2

G2____G1_=yeast*t_21*G2

# Reaction: id = G2____G2___rI, name = G2 -> G2 + rI

G2____G2_=yeast*rho_b*G2

# Reaction: id = G2___A2____G3, name = G2 + A2 -> G3

G2___A2__=yeast*a_23*G2*A2

# Reaction: id = G3____G2___A2, name = G3 -> G2 + A2

G3____G2_=yeast*t_32*G3

# Reaction: id = G3____G3___rI, name = G3 -> G3 + rI

G3____G3_=yeast*rho_b*G3

# Species:   id = G0, name = G0, affected by kineticLaw

init G0=1.0
dG0/dt=(1/(yeast))*(( 1.0 * G1____G0_) + (-1.0 * G0___A2__) + (-1.0 * G____G___) + ( 1.0 * G____G___))

# Species:   id = G1, name = G1, affected by kineticLaw

init G1=0.0
dG1/dt=(1/(yeast))*((-1.0 * G1____G0_) + ( 1.0 * G0___A2__) + (-1.0 * G1____G1_) + ( 1.0 * G1____G1_) + (-1.0 * G1___A2__) + ( 1.0 * G2____G1_))

# Species:   id = rA, name = rA, affected by kineticLaw

init rA=0.0
drA/dt=(1/(yeast))*((-1.0 * rA___) + ( 1.0 * ____rA) + (-1.0 * rA____rA_) + ( 1.0 * rA____rA_))

# Species:   id = I, name = I, affected by kineticLaw

init I=0.0
dI/dt=(1/(yeast))*((-1.0 * I___) + ( 1.0 * rI____rI_) + (-1.0 * A___I____) + ( 1.0 * AI____A__))

# Species:   id = rI, name = rI, affected by kineticLaw

init rI=0.0
drI/dt=(1/(yeast))*(( 1.0 * G____G___) + ( 1.0 * G1____G1_) + (-1.0 * rI___) + (-1.0 * rI____rI_) + ( 1.0 * rI____rI_) + ( 1.0 * G2____G2_) + ( 1.0 * G3____G3_))

# Species:   id = A, name = A, affected by kineticLaw

init A=0.0
dA/dt=(1/(yeast))*(( 1.0 * rA____rA_) + (-1.0 * A___) + (-1.0 * A___I____) + (-2.0 * _2___A___) + ( 2.0 * A2____2__) + ( 1.0 * AI____A__))

# Species:   id = AI, name = AI, affected by kineticLaw

init AI=0.0
dAI/dt=(1/(yeast))*(( 1.0 * A___I____) + (-1.0 * AI____A__) + (-1.0 * AI___))

# Species:   id = A2, name = A2, affected by kineticLaw

init A2=0.0
dA2/dt=(1/(yeast))*(( 1.0 * G1____G0_) + (-1.0 * G0___A2__) + ( 1.0 * _2___A___) + (-1.0 * A2____2__) + (-1.0 * A2___) + (-1.0 * G1___A2__) + ( 1.0 * G2____G1_) + (-1.0 * G2___A2__) + ( 1.0 * G3____G2_))

# Species:   id = G2, name = G2, affected by kineticLaw

init G2=0.0
dG2/dt=(1/(yeast))*(( 1.0 * G1___A2__) + (-1.0 * G2____G1_) + (-1.0 * G2____G2_) + ( 1.0 * G2____G2_) + (-1.0 * G2___A2__) + ( 1.0 * G3____G2_))

# Species:   id = G3, name = G3, affected by kineticLaw

init G3=0.0
dG3/dt=(1/(yeast))*(( 1.0 * G2___A2__) + (-1.0 * G3____G2_) + (-1.0 * G3____G3_) + ( 1.0 * G3____G3_))


# Piecewise functions : the mathML piecewise element is transformed into if/then/else expression

piecew1=if (ModelValu  ==  1) then (3*ModelVa_1) else (ModelVa_1)

piecew2=if (ModelValu  ==  1) then (2*ModelVa_1) else (0)

piecew3=if (ModelValu  ==  1) then (1*ModelVa_1) else (0)

piecew4=if (ModelValu  ==  1) then (2*ModelVa_2) else (0)

piecew5=if (ModelValu  ==  1) then (3*ModelVa_2) else (0)


@ meth=cvode, tol=1e-6, atol=1e-8
# @ maxstor=1e6
@ bound=40000, total=200
done

